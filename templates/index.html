<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Twilio Browser Dialer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />
    <style>
      body {
        font-family: system-ui, sans-serif;
        padding: 2rem 15%;
        text-align: center;
      }
      input[type="tel"] {
        width: 100%;
        padding: 0.5rem;
        margin-top: 0.25rem;
        font-size: 1rem;
      }
      button {
        padding: 0.75rem 1.25rem;
        margin-top: 1rem;
        font-size: 1rem;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
      }
      #call-button {
        background: #0d6efd;
        color: #fff;
      }
      #hangup-button {
        background: #dc3545;
        color: #fff;
      }
      #hold-conf-button {
        background: #ffc107; /* Teal */
        color: #fff;
      }
      #unhold-button {
        background: #198754;
        color: #fff;
      }
      #transfer-button {
        background: #6f42c1;
        color: #fff;
      }
      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #log {
        white-space: pre-wrap;
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 0.5rem;
        font-size: 0.9rem;
        text-align: left;
        margin-top: 1.5rem;
      }
      .log-parent {
        background-color: #fff3cd; /* Yellow */
        padding: 0.5rem;
        border-radius: 0.4rem;
        margin-bottom: 0.5rem;
      }
      .log-child {
        background-color: #d1e7dd; /* Green */
        padding: 0.5rem;
        border-radius: 0.4rem;
        margin-bottom: 0.5rem;
      }
      .log-conference {
        background-color: #cff4fc; /* Blue */
        padding: 0.5rem;
        border-radius: 0.4rem;
        margin-bottom: 0.5rem;
      }
      /* --- Incoming-call accept animation --- */
      @keyframes jiggle {
        0% {
          transform: rotate(-2deg);
        }
        50% {
          transform: rotate(2deg);
        }
        100% {
          transform: rotate(-2deg);
        }
      }

      .jiggle {
        animation: jiggle 0.4s infinite;
      }
    </style>
  </head>
  <body>
    <h1>Twilio Browser Dialer</h1>

    <div style="max-width: 100%; margin: 0 auto; position: relative">
      <input
        id="phoneNumber"
        type="tel"
        placeholder="+14155551234"
        autocomplete="off"
        style="width: 100%; box-sizing: border-box"
      />
      <ul
        id="customDropdown"
        style="
          display: none;
          position: absolute;
          left: 0;
          right: 0;
          top: 100%;
          z-index: 1000;
          background: #fff;
          border: 1px solid #ccc;
          border-top: none;
          list-style: none;
          margin: 0;
          padding: 0;
          max-height: 150px;
          overflow-y: auto;
          width: 100%;
          box-sizing: border-box;
          text-align: left;
          font-family: 'Comic Sans MS', 'Comic Sans', cursive;
          font-size: 1.05rem;
        "
      ></ul>
    </div>

    <div style="margin-top: 1rem">
      <label for="roleToggle">Role:</label>
      <select id="roleToggle" style="padding: 0.5rem; font-size: 1rem">
        <option value="agent">Agent</option>
        <option value="customer">Customer</option>
      </select>
    </div>

    <button id="call-button">Call</button>
    <button id="hangup-button" disabled>Hang Up</button>
    <button id="hold-conf-button" disabled>Hold</button>
    <button id="unhold-button" disabled>Unhold</button>
    <button id="transfer-button" disabled>Transfer</button>

    <!-- Shown only while an incoming call is ringing -->
    <button id="accept-button" style="display: none">Accept</button>

    <!-- Simple ringtone (looping) -->
    <audio
      id="ringtone"
      src="https://actions.google.com/sounds/v1/alarms/phone_alerts_and_rings.wav"
      preload="auto"
      loop
    ></audio>

    <div id="participants-section" style="margin-top: 2rem; display: none">
      <h2>Conference Participants</h2>
      <ul id="participants-list" style="list-style: none; padding: 0"></ul>
    </div>
    <div id="log"></div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://sdk.twilio.com/js/client/v1.13/twilio.min.js"></script>
    <script>
      const urlParams = new URLSearchParams(window.location.search);

      // Generate a random 8-character identity using both lowercase and uppercase letters
      function generateRandomIdentity() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        return Array.from({ length: 8 }, () =>
          chars.charAt(Math.floor(Math.random() * chars.length))
        ).join("");
      }
      const defaultIdentity = generateRandomIdentity();

      let myIdentity =
        urlParams.get("identity") ||
        prompt("Enter your identity", defaultIdentity) ||
        defaultIdentity;
      const socket = io({ query: { identity: myIdentity } }); // Connect to Flask-SocketIO with identity
      const logEl = document.getElementById("log");
      const callButton = document.getElementById("call-button");
      const hangupButton = document.getElementById("hangup-button");
      const holdConfButton = document.getElementById("hold-conf-button");
      const unholdButton = document.getElementById("unhold-button");
      const transferButton = document.getElementById("transfer-button");
      const phoneInput = document.getElementById("phoneNumber");
      const roleSelect = document.getElementById("roleToggle");
      const acceptButton = document.getElementById("accept-button");
      const ringtone = document.getElementById("ringtone");
      let myRole = roleSelect.value;
      roleSelect.addEventListener("change", () => {
        myRole = roleSelect.value;

        // When switching to customer role, automatically select the AIVA number
        if (myRole === "customer") {
          const aivaEntry = phoneNumbers.find((entry) => entry.name === "AIVA");
          if (aivaEntry) {
            phoneInput.value = aivaEntry.number;
          }
        }

        // Mark dropdown stale so it refreshes with role-specific visibility rules
        customDropdown.dataset.dirty = "true";
      });

      let device = null;
      let connection = null;
      let childCallSid = null; // Will be filled when backend emits the child SID
      let parentCallSid = null; // Will be filled alongside the child SID
      let onHold = false; // Track hold state
      let currentConferenceName = null;
      let myCallSid = null;
      // When inside a conference, track a participant (non-agent) call SID to
      // serve as the CHILD leg for subsequent warm-transfers.
      let conferenceChildCallSid = null;
      let participantsInterval = null;
      let dialedTarget = null; // Last number/client dialed to infer roles

      // Will hold an incoming (ringing) Twilio.Connection until accepted / rejected.
      let incomingConnection = null;
      let incomingFromConference = false; // Track whether the current incoming call is a conference invite
      // If this dialer was *invited* into a conference (i.e.
      // received an incoming call whose `From:` starts with "conference"),
      // we flip this flag so later we can treat transfer behaviour differently.
      let wasInvitedConferenceCall = false;

      const appendLog = (msg, type = null) => {
        const time = new Date().toLocaleTimeString();
        const div = document.createElement("div");

        div.textContent = `${time} — ${msg}`;

        if (type === "parent") {
          div.classList.add("log-parent");
        } else if (type === "child") {
          div.classList.add("log-child");
        } else if (type === "conference") {
          div.classList.add("log-conference");
        }

        logEl.appendChild(div);
      };

      // Immediately log the chosen identity
      appendLog(`🆔 Your identity is: ${myIdentity}`);

      async function initDialer() {
        try {
          appendLog("🔑 Fetching Twilio token...");
          const res = await fetch(
            `/token?identity=${encodeURIComponent(myIdentity)}`
          );
          const data = await res.json();
          const token = data.token;
          if (!myIdentity && data.identity) {
            myIdentity = data.identity;
          }
          appendLog(`🔑 Twilio token fetched for ${myIdentity}...`);

          appendLog("⚙️ Initializing Twilio.Device...");
          device = new Twilio.Device(token, { debug: false });

          device.on("ready", () => appendLog("✅ Dialer ready."));
          device.on("error", (err) =>
            appendLog(`❌ Dialer error: ${err.message}`)
          );
          device.on("connect", (conn) => {
            appendLog("📞 Call connected.");
            connection = conn;
            onHold = false;
            hangupButton.disabled = false;
            callButton.disabled = true;
            holdConfButton.disabled = true;
            unholdButton.disabled = true;
            transferButton.disabled = true;

            // Capture Parent Call SID once the media session is established
            conn.on("accept", () => {
              if (conn.parameters && conn.parameters.CallSid) {
                parentCallSid = conn.parameters.CallSid;
                appendLog(
                  `📌 Parent Call SID captured (accept): ${parentCallSid}`,
                  "parent"
                );
              }
            });
          });
          device.on("disconnect", () => {
            appendLog("📴 Call ended.");
            connection = null;
            childCallSid = null;

            // Ensure any ringtone / accept UI is cleared
            ringtone.pause();
            ringtone.currentTime = 0;
            acceptButton.style.display = "none";
            acceptButton.classList.remove("jiggle");
            incomingConnection = null;
            incomingFromConference = false; // Reset flag after call ends
            wasInvitedConferenceCall = false;
            resetCallUI();
          });
          device.on("incoming", (conn) => {
            incomingConnection = conn;

            const fromParam = conn.parameters ? conn.parameters.From : null;
            // Detect if this incoming call is a conference invite
            incomingFromConference = !!(
              fromParam &&
              (fromParam.startsWith("conference") ||
                fromParam.includes("conference-of-"))
            );
            if (incomingFromConference) {
              wasInvitedConferenceCall = true;
            }
            if (fromParam && fromParam.startsWith("conference")) {
              appendLog("📥 Incoming CONFERENCE invite.");
            } else {
              appendLog(
                "📥 Incoming call received." +
                  (fromParam ? ` (From: ${fromParam})` : "")
              );
            }

            // UI: show Accept, start ringtone, disable other controls
            acceptButton.style.display = "";
            acceptButton.disabled = false;
            acceptButton.classList.add("jiggle");
            ringtone.currentTime = 0;
            ringtone.play().catch(() => {});

            callButton.disabled = true;
            holdConfButton.disabled = true;
            transferButton.disabled = true;
            unholdButton.disabled = true;
            hangupButton.disabled = false; // allow rejecting the call

            // If the AGENT has just joined a conference call, immediately allow Hold & Transfer
            if (myRole === "agent" && incomingFromConference) {
              holdConfButton.disabled = false;
              transferButton.disabled = !hasConnectedDialers();
            }
          });
        } catch (err) {
          appendLog(`❌ Error initializing dialer: ${err.message}`);
        }
      }

      callButton.addEventListener("click", () => {
        const phoneNumber = phoneInput.value.trim();
        if (!phoneNumber) {
          appendLog("⚠️ Please enter a phone number.");
          return;
        }

        if (!device || device.status() !== "ready") {
          appendLog("⚠️ Device not ready.");
          return;
        }

        // Find name for the number
        let displayName = null;
        for (const entry of phoneNumbers) {
          if (entry.number === phoneNumber) {
            displayName = entry.name;
            break;
          }
        }
        const namePart = displayName ? ` (${displayName})` : "";

        appendLog(`📲 Calling ${phoneNumber}${namePart}...`);
        connection = device.connect({ To: phoneNumber });

        // Attach listener before any events might fire to capture CallSid reliably
        if (connection) {
          connection.on("accept", () => {
            if (connection.parameters && connection.parameters.CallSid) {
              parentCallSid = connection.parameters.CallSid;
              appendLog(
                `📌 Parent Call SID captured (accept): ${parentCallSid}`,
                "parent"
              );
            }
          });
        }

        dialedTarget = phoneNumber; // remember the dialed target for later role assignment
      });

      hangupButton.addEventListener("click", () => {
        if (connection) {
          appendLog("🔴 Hanging up...");
          onHold = false; // reset hold state so disconnect handler restores UI
          connection.disconnect();
        } else if (incomingConnection) {
          // Reject the ringing call
          appendLog("❌ Rejecting incoming call...");
          incomingConnection.reject();
          incomingConnection = null;
          ringtone.pause();
          ringtone.currentTime = 0;
          acceptButton.style.display = "none";
          acceptButton.classList.remove("jiggle");
          incomingFromConference = false; // Reset flag after call ends
        }
        showParticipantsSection(false);
        stopParticipantsPolling();
        resetCallUI();
      });

      holdConfButton.addEventListener("click", () => {
        if (!childCallSid || !parentCallSid) {
          appendLog("⚠️ Child or Parent Call SID not yet available.");
          return;
        }
        appendLog("⏸️ Placing calls into conference hold...");
        onHold = true;
        callButton.disabled = true;
        const target = `client:${myIdentity}`;
        holdCallViaConference(childCallSid, parentCallSid, target);
      });

      unholdButton.addEventListener("click", () => {
        if (!parentCallSid) {
          appendLog("⚠️ Parent Call SID not yet available.");
          return;
        }
        appendLog("▶️ Attempting to unhold the call...");
        unholdCall(parentCallSid);
      });

      transferButton.addEventListener("click", async () => {
        // Ensure we have the latest participant list and call SIDs
        try {
          await fetchAndRenderParticipants();
        } catch (_) {
          /* network errors ignored – we still attempt transfer */
        }

        let effectiveParentSid;
        let effectiveChildSid;

        if (wasInvitedConferenceCall) {
          // We’re inside a conference; use our own call SID as parent, and
          // the cached non-agent participant SID as child.
          effectiveParentSid = myCallSid;
          effectiveChildSid = conferenceChildCallSid;

          if (!effectiveParentSid || !effectiveChildSid) {
            appendLog(
              `⚠️ Missing SID(s) for transfer. parent=${
                effectiveParentSid ?? "null"
              }, child=${effectiveChildSid ?? "null"}`
            );
            return;
          }
        } else {
          // Normal original flow – require both pre-captured SIDs.
          if (!childCallSid || !parentCallSid) {
            appendLog(
              `⚠️ Missing SID(s) for transfer. parent=${
                parentCallSid ?? "null"
              }, child=${childCallSid ?? "null"}`
            );
            return;
          }
          effectiveParentSid = parentCallSid;
          effectiveChildSid = childCallSid;
        }

        const parentTarget = `client:${myIdentity}`;

        // Get the current list of other connected dialers (excluding ourselves)
        const dialers = getConnectedDialers();
        if (dialers.length === 0) {
          appendLog("⚠️ No active dialers available for warm transfer.");
          transferButton.disabled = true;
          return;
        }

        // Decide which index to pick: 0 for original leg, 1 for invited leg.
        let targetIndex = wasInvitedConferenceCall ? 1 : 0;
        // Fallback to the first available if chosen index is out of bounds.
        if (targetIndex >= dialers.length) {
          targetIndex = 0;
        }
        const transferTo = dialers[targetIndex];

        appendLog(`🔀 Initiating warm transfer to ${transferTo}...`);
        warmTransfer(
          effectiveChildSid,
          effectiveParentSid,
          parentTarget,
          transferTo
        );
      });

      socket.on("call_event", (event) => {
        const {
          status,
          from,
          to,
          note,
          type,
          sid,
          parent_sid,
          event: eventType,
        } = event;

        if (eventType === "ring_duration") {
          appendLog(`🛎️ ${type.toUpperCase()} call rang for: ${note}`);
          return;
        }

        let callTypeLabel = type === "child" ? "CHILD" : "PARENT";
        let logMessage = `[${callTypeLabel}] Event: ${status.toUpperCase()}`;

        if (parent_sid) {
          logMessage += ` | Parent SID: ${parent_sid}`;
        }

        if (note) {
          logMessage += ` | Note: ${note}`;
        }

        logMessage += ` | Call SID: ${sid}`;

        appendLog(logMessage, type);

        // ✅ Enable Hold only when the CHILD call is actually answered (i.e., reaches IN-PROGRESS)
        if (
          type === "child" &&
          (status === "in-progress" || status === "answered")
        ) {
          if (!onHold && !currentConferenceName)
            holdConfButton.disabled = false;
          if (!onHold && !currentConferenceName)
            transferButton.disabled = !hasConnectedDialers();
          unholdButton.disabled = true;
        }

        // 🛑 Ensure Hold is disabled as soon as the PARENT call is connected
        if (
          type === "parent" &&
          (status === "in-progress" || status === "answered")
        ) {
          holdConfButton.disabled = true;
          transferButton.disabled = true;
          unholdButton.disabled = true;
        }

        // Capture Parent Call SID from any parent call event if not already set
        if (type === "parent" && !parentCallSid) {
          parentCallSid = sid;
          appendLog(`📌 Parent Call SID captured: ${parentCallSid}`, "parent");
        }
      });

      socket.on("child_call_sid", (data) => {
        console.log("childCallSid", data);
        childCallSid = data.child_sid;
        parentCallSid = data.parent_sid;
        appendLog(`🔗 Child Call SID received: ${childCallSid}`, "child");
        // ⚠️ Do NOT enable Hold yet; wait until the child call is answered
      });

      socket.on("parent_call_sid", (data) => {
        parentCallSid = data.parent_sid;
        console.log("parentCallSid", parentCallSid);
        appendLog(`🔗 Parent Call SID received: ${parentCallSid}`, "parent");
      });

      socket.on("conference_event", (event) => {
        const {
          event: evtType,
          conference_sid,
          participant_sid,
          call_sid,
          status,
          note,
          participant_label,
          coaching,
          end_conference_on_exit,
          start_conference_on_enter,
          hold,
          muted,
          reason,
          sequence_number,
        } = event;

        let msg = `(${sequence_number}) [${
          participant_label ?? "CONFERENCE"
        }] Event: ${evtType || status || "unknown"}`;
        if (conference_sid) msg += ` | Conf SID: ${conference_sid}`;
        if (participant_sid) msg += ` | Participant SID: ${participant_sid}`;
        if (call_sid) msg += ` | Call SID: ${call_sid}`;
        if (note) msg += ` | Note: ${note}`;
        if (coaching) msg += ` | Coaching: ${coaching}`;
        if (end_conference_on_exit)
          msg += ` | End Conference On Exit: ${end_conference_on_exit}`;
        if (start_conference_on_enter)
          msg += ` | Start Conference On Enter: ${start_conference_on_enter}`;
        if (hold) msg += ` | Hold: ${hold}`;
        if (muted) msg += ` | Muted: ${muted}`;
        if (reason) msg += ` | Reason: ${reason}`;

        appendLog(msg, "conference");

        // Try to detect when we join a conference and set conference name/call sid
        if (event.event === "participant-join") {
          currentConferenceName = event.conference_name;
          // Only set myCallSid when the join event relates to **this** dialer.
          if (event.participant_label === myIdentity) {
            myCallSid = event.call_sid;
            // Enable Hold / Transfer controls now that *this* dialer is inside the conference
            if (myRole === "agent") {
              holdConfButton.disabled = false;
              transferButton.disabled = !hasConnectedDialers();
            }
          } else {
            // A *new* participant joined (not me) – clear onHold state so we can transfer again
            onHold = false;
            if (myRole === "agent") {
              transferButton.disabled = !hasConnectedDialers();
              holdConfButton.disabled = false;
            }
          }
          showParticipantsSection(true);
          fetchAndRenderParticipants();
          startParticipantsPolling();
        }
        if (
          event.event === "participant-leave" &&
          event.call_sid === myCallSid
        ) {
          // We left the conference
          showParticipantsSection(false);
          stopParticipantsPolling();
          resetCallUI();
        }
        if (event.event === "conference-end") {
          showParticipantsSection(false);
          stopParticipantsPolling();
          resetAllState();
          resetCallUI();
        }
        // Always fetch and re-render participants after any conference event
        fetchAndRenderParticipants();
      });

      /**
       * Determine the child role based on the dialed target and the parent's role.
       * Rules:
       *   - If parent is "customer":
       *       - dialedTarget starts with "client:"   -> "agent"
       *       - otherwise                             -> "ai-voice-agent"
       *   - If parent is "agent":
       *       - dialedTarget starts with "client:"   -> "agent"
       *       - otherwise                             -> "customer"
       */
      function getChildRole(dialedTarget, parentRole) {
        const isClientTarget =
          dialedTarget && dialedTarget.startsWith("client:");
        if (parentRole === "customer") {
          return isClientTarget ? "agent" : "ai-voice-agent";
        }
        if (parentRole === "agent") {
          return isClientTarget ? "agent" : "customer";
        }
        // Fallback
        return "customer";
      }

      // Determine the child name based on the parent's role and the dialed target.
      // Rules:
      //   - If parent role is "customer" -> always "aiva".
      //   - If parent role is "agent"   -> keep existing logic: extract client id or default to "sachinists".
      function getChildName(dialedTarget, parentRole) {
        if (parentRole === "customer") {
          return "aiva";
        }
        const isClientTarget =
          dialedTarget && dialedTarget.startsWith("client:");
        return isClientTarget ? dialedTarget.substring(7) : "customer-name";
      }

      function holdCallViaConference(
        childCallSid,
        parentCallSid,
        parentTarget
      ) {
        const payload = {
          child_call_sid: childCallSid,
          parent_call_sid: parentCallSid,
          parent_target: parentTarget,
          identity: myIdentity,
          child_name: getChildName(dialedTarget, myRole),
          parent_name: myIdentity,
          parent_role: myRole,
          child_role: getChildRole(dialedTarget, myRole),
        };
        console.debug("Sending hold-call-via-conference payload", payload);
        fetch("/hold-call-via-conference", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        })
          .then((res) => res.json())
          .then((data) => {
            appendLog(
              `ℹ️ Hold via conference response: ${JSON.stringify(data)}`
            );
            onHold = true;
            holdConfButton.disabled = true;
            transferButton.disabled = true;
            callButton.disabled = true;
            unholdButton.disabled = true; // No unhold for conf hold
            hangupButton.disabled = false; // Allow disconnect
          })
          .catch((err) => {
            appendLog(`❌ Hold via conference request error: ${err.message}`);
          });
      }

      function unholdCall(parentCallSid) {
        const payload = { parent_call_sid: parentCallSid };
        console.debug("Sending unhold-call payload", payload);
        fetch("/unhold-call", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        })
          .then((res) => res.json())
          .then((data) => {
            appendLog(`ℹ️ Unhold response: ${JSON.stringify(data)}`);
            // Wait for incoming reconnect; disable unhold to prevent double click
            unholdButton.disabled = true;
          })
          .catch((err) => {
            appendLog(`❌ Unhold request error: ${err.message}`);
          });
      }

      function warmTransfer(
        childCallSid,
        parentCallSid,
        parentTarget,
        transferTo
      ) {
        const payload = {
          child_call_sid: childCallSid,
          parent_call_sid: parentCallSid,
          parent_target: parentTarget,
          identity: myIdentity,
          child_name: getChildName(dialedTarget, myRole),
          parent_name: myIdentity,
          parent_role: myRole,
          child_role: getChildRole(dialedTarget, myRole),
          transfer_to: transferTo,
        };
        const warmTransferUrl = `${window.location.origin}/transfer/warm-transfer`;
        fetch(warmTransferUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        })
          .then(async (res) => {
            const text = await res.text();
            if (!res.ok) {
              appendLog(`❌ Warm transfer HTTP ${res.status}: ${text}`);
              throw new Error(text);
            }
            appendLog(`ℹ️ Warm transfer response: ${text}`);
            onHold = true;
            holdConfButton.disabled = true;
            transferButton.disabled = true;
            callButton.disabled = true;
            hangupButton.disabled = false;
          })
          .catch((err) => {
            appendLog(`❌ Warm transfer request error: ${err.message}`);
          });
      }

      // Custom dropdown logic (no Bootstrap)
      const customDropdown = document.getElementById("customDropdown");

      // Initial static entries – keep only the user's personal Jio number and a
      // default browser dialer identity.
      let phoneNumbers = [
        {
          name: "AIVA",
          number: "+18559421624",
        },
        {
          name: "Personal Jio",
          number: "+918617020252",
        },
        {
          name: "New Dialer",
          number: `client:${myIdentity}`,
        },
      ];

      // New helper utilities to track other connected dialers
      const getConnectedDialers = () =>
        phoneNumbers
          .filter(
            (entry) =>
              entry.number.startsWith("client:") &&
              entry.number !== `client:${myIdentity}`
          )
          .map((entry) => entry.number);

      const hasConnectedDialers = () => getConnectedDialers().length > 0;

      /**
       * Sync the dropdown list with the currently connected identities.
       * 1. Remove any `client:<id>` entry that is no longer connected.
       * 2. Add any newly-connected identity that isn't already present.
       * 3. Always skip our own identity (myIdentity).
       * 4. Refresh the dropdown UI so the user instantly sees the change.
       */
      function mergeConnectedDialers(identities) {
        // Step 1: prune disconnected identities
        phoneNumbers = phoneNumbers.filter((entry) => {
          if (!entry.number.startsWith("client:")) return true; // keep non-client entries
          const entryId = entry.number.substring(7);
          return identities.includes(entryId);
        });

        // Step 2: add newly connected identities (except ourselves)
        identities.forEach((id) => {
          if (id === myIdentity) return; // never include self
          const num = `client:${id}`;
          const exists = phoneNumbers.some((entry) => entry.number === num);
          if (!exists) {
            phoneNumbers.push({ name: `Client (${id})`, number: num });
          }
        });

        // Step 3: refresh dropdown UI
        const wasOpen = customDropdown.style.display !== "none";
        if (wasOpen) {
          // If it's currently open, re-render immediately so the list updates in place.
          renderDropdown();
        } else {
          // If closed, mark it dirty so the next open gets a fresh render.
          customDropdown.dataset.dirty = "true";
        }

        // Disable transfer button if there are no other dialers
        if (!hasConnectedDialers()) {
          transferButton.disabled = true;
        }
      }

      // Fetch the initial set of connected dialers when the page loads.
      async function loadInitialConnectedDialers() {
        try {
          const res = await fetch("/connected-dialers");
          const identities = await res.json();
          mergeConnectedDialers(identities);
        } catch (e) {
          console.error("Failed to load connected dialers", e);
        }
      }

      // Keep the list up-to-date in real-time via Socket.IO broadcasts.
      socket.on("connected_identities", (identities) => {
        mergeConnectedDialers(identities);
      });

      // Kick off initial load.
      loadInitialConnectedDialers();

      function renderDropdown() {
        customDropdown.innerHTML = "";
        phoneNumbers
          .filter((entry) => {
            // Exclude our own identity from list
            if (entry.number === `client:${myIdentity}`) return false;

            // If the current role is customer, show ONLY the AIVA entry
            if (myRole === "customer") {
              return entry.name === "AIVA";
            }

            // For agents, show everything else
            return true;
          })
          .forEach((entry) => {
            const li = document.createElement("li");
            li.textContent = `${entry.name}: ${entry.number}`;
            li.style.padding = "0.5rem 1rem";
            li.style.cursor = "pointer";
            li.style.textAlign = "left";
            li.style.fontFamily = "'Comic Sans MS', 'Comic Sans', cursive";
            li.addEventListener("mousedown", (e) => {
              e.preventDefault();
              phoneInput.value = entry.number;
              customDropdown.style.display = "none";
            });
            li.addEventListener("mouseover", () => {
              li.style.background = "#f0f0f0";
            });
            li.addEventListener("mouseout", () => {
              li.style.background = "#fff";
            });
            customDropdown.appendChild(li);
          });
        customDropdown.style.display = "block";
      }

      phoneInput.addEventListener("focus", () => {
        if (customDropdown.dataset.dirty === "true") {
          renderDropdown();
          delete customDropdown.dataset.dirty;
        } else {
          renderDropdown();
        }
      });
      phoneInput.addEventListener("input", () => {
        renderDropdown();
      });
      phoneInput.addEventListener("blur", () => {
        setTimeout(() => (customDropdown.style.display = "none"), 200);
      });

      // --- PARTICIPANT UI LOGIC ---
      function showParticipantsSection(show) {
        document.getElementById("participants-section").style.display = show
          ? ""
          : "none";
      }

      async function fetchAndRenderParticipants() {
        if (!currentConferenceName) return;
        try {
          let url = `/conference/${encodeURIComponent(
            currentConferenceName
          )}/participants`;
          if (myCallSid) {
            url += `?call_sid=${myCallSid}`;
          }
          const res = await fetch(url);
          const participants = await res.json();
          const list = document.getElementById("participants-list");
          list.innerHTML = "";
          participants.forEach((p) => {
            const li = document.createElement("li");
            li.style.marginBottom = "0.5rem";
            const isSelf =
              p.call_sid === myCallSid || p.participant_label === myIdentity;

            // Keep track of another leg in the conference (not self) to act as
            // the CHILD leg for warm-transfer. Prefer a non-agent role, but if
            // none exists fall back to the first other participant.
            if (!isSelf) {
              if (p.role !== "agent") {
                conferenceChildCallSid = p.call_sid;
              } else if (!conferenceChildCallSid) {
                conferenceChildCallSid = p.call_sid; // fallback
              }
            }

            let label = `${p.participant_label} (${p.role}) [On Hold: ${
              p.on_hold ? "Yes" : "No"
            }${p.on_hold ? "" : `, Muted: ${p.muted ? "Yes" : "No"}`}]`;
            if (isSelf) label += " (You)";
            li.textContent = label;
            // Only allow controls for others, never for self
            if (!isSelf) {
              // Mute/unmute button for OTHER participants
              const muteBtn = document.createElement("button");
              muteBtn.textContent = p.muted ? "Unmute" : "Mute";
              muteBtn.style.marginLeft = "0.5rem";
              muteBtn.onclick = async () => {
                await fetch("/conference/mute", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    conference_name: currentConferenceName,
                    call_sid: p.call_sid,
                    mute: !p.muted,
                  }),
                });
                fetchAndRenderParticipants();
              };
              li.appendChild(muteBtn);
              // Hold/unhold button for OTHER participants
              const holdBtn = document.createElement("button");
              holdBtn.textContent = p.on_hold ? "Unhold" : "Hold";
              holdBtn.style.marginLeft = "0.5rem";
              holdBtn.onclick = async () => {
                await fetch("/conference/hold", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    conference_name: currentConferenceName,
                    call_sid: p.call_sid,
                    hold: !p.on_hold,
                  }),
                });
                fetchAndRenderParticipants();
              };
              li.appendChild(holdBtn);
              // Kick button for OTHER participants
              const kickBtn = document.createElement("button");
              kickBtn.textContent = "Kick";
              kickBtn.style.marginLeft = "0.5rem";
              kickBtn.onclick = async () => {
                await fetch("/conference/kick", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    conference_name: currentConferenceName,
                    call_sid: p.call_sid,
                    requester_call_sid: myCallSid,
                  }),
                });
                fetchAndRenderParticipants();
              };
              li.appendChild(kickBtn);
            } else {
              // --- CONTROLS FOR *SELF* PARTICIPANT ---
              // Allow self mute/unmute and hold/unhold, but prohibit self-kick.
              const selfMuteBtn = document.createElement("button");
              selfMuteBtn.textContent = p.muted ? "Unmute" : "Mute";
              selfMuteBtn.style.marginLeft = "0.5rem";
              selfMuteBtn.onclick = async () => {
                await fetch("/conference/mute", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    conference_name: currentConferenceName,
                    call_sid: p.call_sid,
                    mute: !p.muted,
                  }),
                });
                fetchAndRenderParticipants();
              };
              li.appendChild(selfMuteBtn);

              const selfHoldBtn = document.createElement("button");
              selfHoldBtn.textContent = p.on_hold ? "Unhold" : "Hold";
              selfHoldBtn.style.marginLeft = "0.5rem";
              selfHoldBtn.onclick = async () => {
                await fetch("/conference/hold", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    conference_name: currentConferenceName,
                    call_sid: p.call_sid,
                    hold: !p.on_hold,
                  }),
                });
                fetchAndRenderParticipants();
              };
              li.appendChild(selfHoldBtn);

              const disabledKickBtn = document.createElement("button");
              disabledKickBtn.textContent = "Kick";
              disabledKickBtn.disabled = true; // never allow self-kick
              disabledKickBtn.style.marginLeft = "0.5rem";
              li.appendChild(disabledKickBtn);
            }
            list.appendChild(li);
          });
        } catch (e) {
          // Optionally log error
        }
      }

      function startParticipantsPolling() {
        if (participantsInterval) clearInterval(participantsInterval);
        participantsInterval = setInterval(fetchAndRenderParticipants, 5000);
      }
      function stopParticipantsPolling() {
        if (participantsInterval) clearInterval(participantsInterval);
        participantsInterval = null;
      }

      function resetCallUI() {
        callButton.disabled = false;
        hangupButton.disabled = true;
        holdConfButton.disabled = true;
        transferButton.disabled = true;
        unholdButton.disabled = true;

        // Hide accept button and stop any jiggle effect
        acceptButton.style.display = "none";
        acceptButton.classList.remove("jiggle");
      }

      function resetAllState() {
        connection = null;
        childCallSid = null;
        parentCallSid = null;
        onHold = false;
        currentConferenceName = null;
        myCallSid = null;
      }

      // Accept incoming ringing call
      acceptButton.addEventListener("click", () => {
        if (!incomingConnection) return;

        appendLog("✅ Accepting incoming call...");

        // Capture CallSid once the connection media starts
        incomingConnection.on("accept", () => {
          if (
            incomingConnection.parameters &&
            incomingConnection.parameters.CallSid
          ) {
            myCallSid = incomingConnection.parameters.CallSid;
            appendLog(
              `📌 My Call SID captured (accept): ${myCallSid}`,
              "parent"
            );
          }
        });

        ringtone.pause();
        ringtone.currentTime = 0;

        acceptButton.disabled = true;
        acceptButton.classList.remove("jiggle");
        acceptButton.style.display = "none";

        incomingConnection.accept();
        connection = incomingConnection;
        incomingConnection = null;
        incomingFromConference = false; // Reset flag after call ends
      });

      initDialer();
    </script>
  </body>
</html>
